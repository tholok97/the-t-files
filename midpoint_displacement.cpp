// Hand-in 4 in Mathematics for Programming
// Thomas LÃ¸kkeborg 
// thomahl@stud.ntnu.no
//
// Generates 2d terrain by doing iteraions of the midpoint displacement
//  algorithm


#include <SFML/Graphics.hpp>    
#include <vector>               
#include <random>               
#include <cmath>                
#include <iostream>             

//--------------------------------- FUNCTIONS ----------------------------------

// Interpolate between value a and b with the given weight
float lerp(float a, float b, float weight) {
    return (1.0f - weight)*a + weight*b;
}

// Return a random float in the range [min, max)
float randrangeF(float min, float max) {
    static std::default_random_engine engine(time(0));
    std::uniform_real_distribution<float> distribution(min, max);
    return distribution(engine);
}

// Return a random int in the range [min, max)
int randrangeI(int min, int max) {
    static std::default_random_engine engine(time(0));
    std::uniform_int_distribution<> distribution(min, max);
    return distribution(engine);
}

//----------------------- MIDPOINT DISPLACEMENT TERRAIN ------------------------

// 2d terrain generated by iterations of the midpoint displacement algorithm
class MidpointDisplacementTerrain {
    private:
        sf::VertexArray vertices;       // Vertices of the terrain
        float originalVariation;        // Variation given in constructor
        float variation;                // Displacementrange to use in algorithm
        int iterations;                 // Iteration count

    public:
        // Construct based on leftmost and rightmost vertex and variation
        MidpointDisplacementTerrain(sf::Vector2f vec1, sf::Vector2f vec2,
                float vari): vertices(sf::LineStrip), variation(vari),
                originalVariation(vari), iterations(0) {
            vertices.append(vec1);
            vertices.append(vec2);
        }

        // Reset the terrain to state it was in after constructor
        void reset() {
            sf::Vertex vec1(vertices[0]);       // store starting vertices
            sf::Vertex vec2(vertices[vertices.getVertexCount()-1]);
            vertices.clear();                   // clear VertexArray
            vertices.append(vec1);              // re-add leftmost, rightmost
            vertices.append(vec2);              //  vertices
            variation = originalVariation;      // reset variation
            iterations = 0;                     // reset iterations
        }

        // Do one iteration of the midpoint displacement algorithm
        void iterate() {

            // Vertices after iteration
            std::vector<sf::Vertex> nextVertices;

            // For each line segment, add vertex at midpoint and displace it
            for (int i = 0; i < vertices.getVertexCount()-1; ++i) {
                float xPos = (vertices[i].position.x        // x of new vertex
                        + vertices[i+1].position.x) / 2;
                float yPos = (vertices[i].position.y        // y of new vertex
                        + vertices[i+1].position.y) / 2;

                // Displace yPos by a random value in the range [-vari, vari)
                yPos += randrangeF(-variation, variation);

                // Add left vertex of segment and new vertex to nextVertices
                nextVertices.push_back(vertices[i]);
                nextVertices.push_back(sf::Vertex(sf::Vector2f(xPos, yPos)));
            }

            // Add the last vector to nextVertices
            nextVertices.push_back(vertices[vertices.getVertexCount()-1]);

            // Clear the VertexArray and add vertices from nextVertices
            vertices.clear();
            for (sf::Vertex& vec : nextVertices) {
                vertices.append(vec);
            }

            variation /= 2;     // halve variation
            ++iterations;       // increment iterations
        }

        // Do 'count' iterations
        void iterate(int count) {
            for (int i = 0; i < count; ++i) {
                iterate();
            }
        }

        // Draw terrain to 'rt'
        void draw(sf::RenderTarget& rt) {
            rt.draw(vertices);
        }

        // Return iterations
        int getIterations() {
            return iterations;
        }

        // Return vertex count
        int getVertexCount() {
            return vertices.getVertexCount();
        }

        // Print information about the state of the terrain
        void print() {
            std::cout << "Iterations: " << getIterations() << "\tVertices: "
                    << getVertexCount() << std::endl;
        }
};

//------------------------------------ MAIN ------------------------------------

int main() {

    const int WINDOWSIZE = 512;     // width, height of window

    // set up RenderWindow
    sf::RenderWindow window(sf::VideoMode(WINDOWSIZE, WINDOWSIZE), "Perlin");

    // set up Clock
    sf::Clock clock;
    clock.restart();

    // set up midpoint dispacement terrain
    MidpointDisplacementTerrain mdt(sf::Vector2f(0, WINDOWSIZE/2),
            sf::Vector2f(WINDOWSIZE, WINDOWSIZE/2), 150);

    bool spacePressed = false;      // variables to keep track of pressed keys
    bool returnPressed = false;
    bool escapePressed = false;


    // run the program as long as the window is open
    while (window.isOpen()) {

        // poll events
        sf::Event event;

        while (window.pollEvent(event)) {
            // "close requested" event: we close the window
            if (event.type == sf::Event::Closed)
                window.close();
        }


        // React to keypresses. Press space to do an iteration, escape to reset 
        //  and enter to build new terrain with as many iteraions
        if(sf::Keyboard::isKeyPressed(sf::Keyboard::Escape) && !escapePressed) {
            escapePressed = true;
            std::cout << "---------------------------------------" << std::endl;
            mdt.reset();
            mdt.print();
        } else if(!sf::Keyboard::isKeyPressed(sf::Keyboard::Escape)
                && escapePressed) {
            escapePressed = false;
        } else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Return)
                && !returnPressed) {
            returnPressed = true;
            std::cout << "---------------------------------------" << std::endl;
            int prevIterations = mdt.getIterations();
            mdt.reset();
            mdt.iterate(prevIterations);
            mdt.print();
        } else if(!sf::Keyboard::isKeyPressed(sf::Keyboard::Return)
                && returnPressed) {
            returnPressed = false;
        } else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Space)
                && !spacePressed) {
            spacePressed = true;
            mdt.iterate();
            mdt.print();
        } else if (!sf::Keyboard::isKeyPressed(sf::Keyboard::Space)
                && spacePressed) {
            spacePressed = false;
        }

        float dt = clock.restart().asSeconds();     // update delta

        window.clear(sf::Color::Black);             // clear window
        mdt.draw(window);                           // draw mdt
        window.display();                           // display window
    }

    return 0;
}

